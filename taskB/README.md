# Задача B. Телефонные номера

В этом раит-апе задача представлена в отдельной папке и содержит два файла:

1. **задача.pdf** — полная формулировка задачи.
2. **Решение.py** — файл с готовым кодом решения.

Раит-ап разбит на три раздела:

1. **Подробное объяснение вопроса**
2. **Теоретическое объяснение решения**
3. **Подробный разбор кода решения**

---

## 1. Подробное объяснение вопроса

Задача требует определить, можно ли строку, состоящую из цифр, полностью разбить на корректные российские мобильные номера.

Ключевые моменты:

* Российский мобильный номер состоит из **11 цифр** и начинается с **«79»**.
* Нужно проверить, можно ли разделить строку на блоки длиной 11 символов, каждый из которых является корректным номером.
* Строка должна быть **полностью покрыта блоками** (каждая цифра входит ровно в один блок).

Примеры:

* Строка `7916123432179999999999` длиной 22 символа разбивается на два корректных номера → ответ `1`.
* Строка `2025` длиной 4 символа не может образовать корректный номер → ответ `0`.

---

## 2. Теоретическое объяснение решения

Для решения задачи используется простая логика:

1. Проверяем, делится ли длина строки на 11.

   * Если нет — невозможно полностью разделить строку на номера → выводим `0`.
2. Если делится, проходим по каждому сегменту длиной 11 и проверяем первые две цифры:

   * Они должны быть `7` и `9` соответственно.
   * Если хотя бы один сегмент не соответствует — строку разделить нельзя → выводим `0`.
3. Если все сегменты корректны → выводим `1`.

Этот подход работает за **O(n)**, что достаточно быстро для ( n \leq 10^4 ).

---

## 3. Подробный разбор кода решения

```python
# Считываем длину строки
n = int(input())

# Считываем саму строку с цифрами
s = input().strip()

# Проверяем, можно ли разбить строку на блоки длиной 11
if n % 11 != 0:
    print(0)
else:
    # Вычисляем количество блоков
    segments = n // 11
    
    # Проходим по каждому блоку
    for i in range(segments):
        start_index = i * 11  # индекс начала текущего блока
        
        # Проверяем первые две цифры блока
        if s[start_index] != '7' or s[start_index + 1] != '9':
            print(0)
            break
    else:
        # Все блоки корректны
        print(1)
```

Пояснения:

* `n % 11 != 0` — строка не кратна 11, разбиение невозможно.
* `segments = n // 11` — количество потенциальных номеров в строке.
* Цикл `for i in range(segments)` проходит по каждому сегменту.
* `start_index` — индекс первой цифры текущего блока.
* Проверка `s[start_index] != '7' or s[start_index + 1] != '9'` гарантирует, что блок начинается с «79».
* Конструкция `else` после цикла срабатывает, если цикл завершился без `break`, то есть все номера корректны.
